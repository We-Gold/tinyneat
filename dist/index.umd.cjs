(function(G,P){typeof exports=="object"&&typeof module<"u"?P(exports):typeof define=="function"&&define.amd?define(["exports"],P):(G=typeof globalThis<"u"?globalThis:G||self,P(G.tinyneat={}))})(this,function(G){"use strict";const P=n=>{const e={},t={};for(const o of n){if(!o.enabled)continue;const[i,s]=o.connection;i in e||(e[i]=[]),s in t||(t[s]=[]),s in e||(e[s]=[]),i in t||(t[i]=[]),e[i].push(s),t[s].push(i)}return{inputToOutput:e,outputToInput:t}},I=(n,e)=>{const t={};for(const[s,l]of Object.entries(e))t[parseInt(s)]=l.length;const o=Object.entries(e).filter(([,s])=>s.length===0).map(([s])=>+s),i=[];for(;o.length>0;){const s=o.pop();i.push(s);for(const l of n[s])--t[l]===0&&o.push(l)}return i.length===Object.keys(e).length?i:[]},C={sigmoid:n=>1/(1+Math.exp(-n)),modifiedSigmoid:n=>1/(1+Math.exp(-4.9*n)),tanh:n=>Math.tanh(n),relu:n=>n>0?n:0,posAndNegSigmoid:n=>2/(1+Math.exp(-n))-1},g=n=>Math.random()<=n,v=n=>n[A(n)],A=n=>Math.round(Math.random()*(n.length-1)),w=n=>(2*Math.random()-1)*n,F=Object.freeze(Object.defineProperty({__proto__:null,chooseRandom:v,chooseRandomIndex:A,random:g,uniformRandomWeight:w},Symbol.toStringTag,{value:"Module"})),M=(n,e,t,o)=>{const i={};for(const c of t)i[c.connection.toString()]=c.weight;const{inputToOutput:s,outputToInput:l}=P(t),r=I(s,l);if(r.length===0)throw new Error("Received an unexpected graph structure, make sure the ANN is configured correctly.");return{process:c=>{if(c.length!==n)throw new Error(`Received inputs of length ${c.length}, but expected length ${n}`);const u=Array(t.length).fill(0);for(const a of r)if(a<n)u[a]=c[a];else{let m=0;for(const f of l[a])m+=i[[f,a].toString()]*u[f];u[a]=o(m)}const d=Array(e).fill(0);for(let a=0;a<u.length;a++)r[a]>=n&&r[a]<n+e&&(d[r[a]-n]=u[a]);return d}}},T=(n,e)=>n.weight-e.weight,E=(n,e)=>{n.weight+=w(e)},R=n=>({...n}),k=(n,e)=>{const t=(n.weight+e.weight)/2;return{...n,weight:t}},B=(n,e)=>({...n,weight:w(e)}),L=n=>({...n,weight:1}),$=(n,e)=>({...n,weight:e.weight}),W={weightMutationRange:1,activation:"posAndNegSigmoid"},j=(n={})=>{const e={...W,...n};return{createNetwork:(t,o,i)=>M(t,o,i,C[e.activation]),calculateGeneDistance:T,mutateGeneWeight:t=>E(t,e.weightMutationRange),cloneGene:R,averageGenes:k,configureRandomGene:t=>B(t,e.weightMutationRange),configureNewGene:L,configureCloneGene:$}},O=n=>({handleInitialPopulation:o=>n.forEach(i=>{var s;return(s=i.handleInitialPopulation)==null?void 0:s.call(i,o)}),handleEvolve:o=>n.forEach(i=>{var s;return(s=i.handleEvolve)==null?void 0:s.call(i,o)})}),_=()=>({handleInitialPopulation:t=>{console.log("Beginning NEAT"),console.log("______________"),console.log(`Initial Population Size: ${t.config.initialPopulationSize}`),console.log("Complete Config: "),console.log(t.config),console.log("")},handleEvolve:t=>{var o;t.complete?console.log(`NEAT completed at generation ${t.generation}:`):console.log(`Results of generation ${t.generation}:`),console.log(`Population Size: ${t.population.length}`),console.log(`Number of Species: ${t.species.length}`),console.log(`Max Fitness: ${(o=t.bestGenomes)==null?void 0:o[0].fitness}`),t.complete&&(console.log("Best Genomes: "),console.log(t.bestGenomes)),console.log("")}}),D=Object.freeze(Object.defineProperty({__proto__:null,ANNPlugin:j,Activation:C,ConsoleLogger:_,LoggingManager:O,createAdjacencyList:P,helpers:F,topologicalSort:I},Symbol.toStringTag,{value:"Module"})),V={initialPopulationSize:150,maxGenerations:100,maximumStagnation:15,excessCoefficient:1,disjointCoefficient:1,weightDifferenceCoefficient:.4,compatibilityThreshold:3,survivalThreshold:.2,mutateOnlyProbability:.25,mateOnlyProbability:.2,addNodeProbability:.03,addLinkProbability:.05,mutateWeightProbability:.3,interspeciesMatingRate:.01,mateByChoosingProbability:.6,mateByAveragingProbability:.4,reenableConnectionProbability:.01,fitnessSort:"max",largeNetworkSize:20,minimumSpeciesSize:2,hallOfFameSize:10,inputSize:3,outputSize:2,nnPlugin:j(),loggingPlugins:[_()]},q=(n,e)=>{const t=[];for(let i=0;i<e.inputSize;i++)for(let s=0;s<e.outputSize;s++){const l=[i,e.inputSize+s],r=n.getInnovation(l);t.push(e.nnPlugin.configureRandomGene({connection:l,enabled:!0,innovationNumber:r}))}const o=e.inputSize+e.outputSize-1;return N(t,o,e)},N=(n,e,t)=>{if(t.inputSize<1||t.outputSize<1)throw new Error("Invalid neural network input or output size. Verify that there are at least 1 of each.");const o=t.nnPlugin.createNetwork(t.inputSize,t.outputSize,n);return{genes:n,fitness:0,adjustedFitness:0,process:o.process,maxGeneIndex:e}},H=(n,e,t)=>{e.genes.length>n.genes.length&&([n,e]=[e,n]);const o=n.genes.length,i=e.genes.length,s=o-i;let l=0,r=0,h=0,c=0,u=0;const d=o>t.largeNetworkSize?o:1;for(;c<o&&u<i;)n.genes[c].innovationNumber===e.genes[u].innovationNumber?(r+=t.nnPlugin.calculateGeneDistance(n.genes[c++],n.genes[u++]),h++):n.genes[c].innovationNumber>e.genes[u].innovationNumber?(l++,u++):n.genes[c].innovationNumber<e.genes[u].innovationNumber&&(l++,c++);return t.excessCoefficient*s/d+t.disjointCoefficient*l/d+t.weightDifferenceCoefficient*(r/h)},z=(n,e,t)=>{const o=e.adjustedFitness===n.adjustedFitness;e.adjustedFitness>n.adjustedFitness&&([n,e]=[e,n]);const i=o?Math.max(n.maxGeneIndex,e.maxGeneIndex):n.maxGeneIndex,s=n.genes.length,l=e.genes.length,r=[];let h=0,c=0;for(;h<s;){const u=n.genes[h],d=e.genes[c];if(c>=l){const a=t.nnPlugin.cloneGene(u);g(t.reenableConnectionProbability)&&(a.enabled=!0),r.push(),h++}else if(u.innovationNumber===d.innovationNumber){let a;g(t.mateByChoosingProbability)?a=t.nnPlugin.cloneGene(Math.random()<.5?u:d):a=t.nnPlugin.averageGenes(u,d),g(t.reenableConnectionProbability)&&(a.enabled=!0),r.push(a),h++,c++}else if(u.innovationNumber>d.innovationNumber){const a=t.nnPlugin.cloneGene(u);g(t.reenableConnectionProbability)&&(a.enabled=!0),r.push(a),h++,c++}else if(u.innovationNumber<d.innovationNumber){if(o){const a=t.nnPlugin.cloneGene(d);g(t.reenableConnectionProbability)&&(a.enabled=!0),r.push(a),c++}h++}}return{newGenes:r,maxGeneIndex:i}},J=(n,e,t,o,i,s,l)=>{const r=Array.from({length:o+1},(b,S)=>S),h=r.slice();h.splice(i,s);let c=v(h);const u=r.slice(i);let d=v(u);if(c===d)return;const a=t.findIndex(b=>b===c),m=t.findIndex(b=>b===d);a>m&&([c,d]=[d,c]);const f=n.find(b=>b.connection[0]===c&&b.connection[1]===d);if(f!==void 0){f.enabled=!0;return}const p=[c,d],y=e.getInnovation(p);n.push(l.nnPlugin.configureNewGene({connection:p,enabled:!0,innovationNumber:y}))},K=(n,e,t,o)=>{const i=v(n);i.enabled=!1;const s=t+1,l=[i.connection[0],s],r=[s,i.connection[1]];return n.push(o.nnPlugin.configureNewGene({connection:l,enabled:!0,innovationNumber:e.getInnovation(l)})),n.push(o.nnPlugin.configureCloneGene({connection:r,enabled:!0,innovationNumber:e.getInnovation(r)},i)),s},Q=(n,e,t)=>{for(let i=0;i<e.length;i++)e[i]=e[i].slice(0,1);const o=e.map(()=>({distance:1/0,i:0}));for(const i of n){let s=!1;for(const[l,r]of e.entries()){const h=H(r[0],i,t);h<t.compatibilityThreshold&&!s&&(r.push(i),h<o[l].distance&&(o[l]={distance:h,i:r.length-1}),s=!0)}s||(e.push([i]),o.push({distance:1/0,i:0}))}for(const[i,s]of e.entries())s[0]=s.splice(o[i].i,1)[0]},U=(n,e,t,o)=>{Q(n,e,o),X(e);const i=Y(n,e),s=[];for(const[l,r]of e.entries()){const h=r.sort((d,a)=>a.adjustedFitness-d.adjustedFitness),c=h.slice(0,Math.max(r.length*o.survivalThreshold,o.minimumSpeciesSize)),u=h[0];s.push(N(structuredClone(u.genes),u.maxGeneIndex,o));for(let d=0;d<Math.max(i[l]-1,o.minimumSpeciesSize);d++){const a=v(c);let m=v(c);g(o.interspeciesMatingRate)&&(m=v(v(e)));let f,p;if(g(o.mateOnlyProbability)){const y=z(a,m,o);f=y.newGenes,p=y.maxGeneIndex}else{if(g(o.mutateOnlyProbability))f=structuredClone(a.genes),p=a.maxGeneIndex;else{const x=z(a,m,o);f=x.newGenes,p=x.maxGeneIndex}const{inputToOutput:y,outputToInput:b}=P(f),S=I(y,b);g(o.addLinkProbability)?J(f,t,S,p,o.inputSize,o.outputSize,o):g(o.addNodeProbability)&&(p=K(f,t,p,o));for(const x of f)g(o.mutateWeightProbability)&&o.nnPlugin.mutateGeneWeight(x)}s.push(N(f,p,o))}}return s},X=n=>{for(const e of n)for(const t of e)t.adjustedFitness=t.fitness/e.length},Y=(n,e)=>{const t=e.map(i=>i.reduce((s,l)=>s+l.adjustedFitness,0)/i.length),o=t.reduce((i,s)=>i+s,0);return t.map(i=>Math.round(i/o*n.length))},Z=n=>{const e=Array(n);let t=-1/0;return{tryAdding:s=>{var r;if(s.fitness<t)return;const l=e.findIndex(h=>h&&h.fitness<=s.fitness);l===-1?e.unshift(s):l===e.length-1?e.push(s):e.splice(l,0,s),e.length>n&&e.pop(),t=((r=e.at(-1))==null?void 0:r.fitness)??-1/0},getBestGenomes:()=>e}},ee=()=>{let n=0;const e={},t=i=>{const s=n++;return e[i.toString()]=s,s};return{addInnovation:t,getInnovation:i=>e[i.toString()]??t(i)}},ne=(n={})=>{var m;const e={...V,...n},t=O(e.loggingPlugins);let o=Array(e.initialPopulationSize);const i=[],s=ee(),l=Z(e.hallOfFameSize);for(let f=0;f<e.initialPopulationSize;f++)o[f]=q(s,e);(m=t.handleInitialPopulation)==null||m.call(t,{population:o,config:e});const r=()=>o,h=()=>o.entries();let c=0;const u=()=>c,d=()=>c>=e.maxGenerations;return{getPopulation:r,getPopulationIndexed:h,getCurrentGeneration:u,complete:d,evolve:()=>{var f;switch(e.fitnessSort){case"max":break;case"min":o.forEach(p=>p.fitness*=-1)}o.forEach(p=>l.tryAdding(p)),o=U(o,i,s,e),c++,(f=t.handleEvolve)==null||f.call(t,{population:o,config:e,generation:c,species:i,bestGenomes:l.getBestGenomes(),complete:d()})},getBestGenomes:l.getBestGenomes}};G.TinyNEAT=ne,G.plugins=D,Object.defineProperty(G,Symbol.toStringTag,{value:"Module"})});
